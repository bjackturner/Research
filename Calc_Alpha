# Research 1

import numpy as np
from math import *
import matplotlib.pyplot as plt
import scipy as sp

def th_tbm(m,b, gamma): #explicit form of the theta-beta-M relation
    th = np.arctan((2*(m*np.sin(b))**2-2)/(m**2*(gamma+np.cos(2*b))+2)/np.tan(b))
    return abs(th)

def calculate_M2(M1,gamma,beta):
    if beta == np.pi/2:
        M2 = np.sqrt((M1**2 + (2 /(gamma - 1))) / (((2 * gamma)/(gamma - 1)) * M1**2 - 1))
        PR = 1 + (2 * gamma / (gamma + 1)) * (M1**2 - 1)
        m = ((gamma + 1) * M1**2)/(2 + ((gamma - 1) * M1**2))
        TR = ((2 * gamma * M1**2 - (gamma - 1)) * ((gamma - 1) * M1**2 + 2))/((gamma + 1)**2 * M1**2)
        return M2, PR, m, TR
    
    elif beta < np.pi/2:
        th = th_tbm(M1, beta, gamma)
        M1n = M1 * np.sin(beta)
        M2n = (np.sqrt((M1n**2 + (2 /(gamma - 1))) / (((2 * gamma)/(gamma - 1)) * M1n**2 - 1)))
        PR = 1 + (2 * gamma / (gamma + 1)) * (M1n**2 - 1)
        m = ((gamma + 1) * M1n**2)/(2 + ((gamma - 1) * M1n**2))
        TR = ((2 * gamma * M1n**2 - (gamma - 1)) * ((gamma - 1) * M1n**2 + 2))/((gamma + 1)**2 * M1n**2)
        return M1n, M2n, PR, m, TR
        
def alpha_s(a,m):
    # Calculates the angle and entropy angle
    a_s = np.arctan(np.tan(a)/m)
    while a_s < 0:
        a_s = a_s + np.pi

    return a_s

def calculate_aPrime(M1,a):
    # Find alpha prime. A new angle that is related to alpha
    if a == 0:
        return 0
    
    else:
        aPrime = np.arctan(1/((1/np.tan(a)) + (1/(M1 * np.sin(a)))))
        if aPrime < 0:
            aPrime = aPrime + np.pi

        return aPrime

def Crit_Angles(M1, gamma,beta):

    if beta == np.pi/2:
        M2, PR, m, TR = calculate_M2(M1, gamma, beta)

    elif beta < np.pi/2:
        M1, M2, PR, m, TR = calculate_M2(M1, gamma, beta)

    aM = np.arccos(-1/M1)
    acu = bisection_solve(0.000000001, np.pi, -1, 1e-6, M1, M2, m) # Find acl
    acl = bisection_solve(0.000000001, np.pi, 1, 1e-6, M1, M2, m) # Find acu
    ac = np.arctan((m * M2)/(np.sqrt(1 - M2**2)))

    return aM, acu, acl, ac

def calculate_decay_rate(M2,m,a):
    # Solve for Decay Rate, Zeta, and Pressure Wave Angle (ap). Values found if regime is propagative or nonpropagative
    ac = np.arctan((m * M2) / (np.sqrt(1 - M2**2))) # Critical Angle
    acp = np.arccos(-M2) # Resulting Angle of Pressure 

    if a < 0:
        ap = np.arctan(np.tan(acp)/((np.tan(ac)/np.tan(a)) - ((1/M2) * np.sqrt((np.tan(ac)/np.tan(a))**2 - 1))))
        if ap < 0:
            ap = ap + np.pi
        decay_rate = 0
        Zeta = 1

    elif a > 0:
        ap = np.arctan(np.tan(acp)/((np.tan(ac)/np.tan(a)) + ((1/M2) * np.sqrt((np.tan(ac)/np.tan(a))**2 - 1))))
        while ap < np.pi:
            ap = ap + np.pi
        decay_rate = 0
        Zeta = 1

    elif a > 100:
        # NonPropagative Regime both slow and fast wave
        ap = np.arctan(1/(((1/np.tan(acp)) * (1/np.tan(a)))/(1/np.tan(ac))))
        decay_rate = (abs((1/np.tan(acp))*np.sin(ap))/M2)*np.sqrt(1-(np.tan(ac)/np.tan(a))**2)
        Zeta = np.sqrt(1 - decay_rate**2 + 2*1J*decay_rate*np.cos(ap))

    return ap, decay_rate, Zeta

def calculate_decay_rate_prime(M1,M2,m,a,aPrime):
    deg = 180 / np.pi
    # Solve for Decay Rate, Zeta, and Pressure Wave Angle (ap). Values found if regime is propagative or nonpropagative
    ac = np.arctan((m * M2)/(np.sqrt(1 - M2**2))) # Critical Angle
    acp = np.arccos(-M2) # Resulting Angle of Pressure 
    # Upper and Lower angles of critical region (Acoustic Waves)
    aM = np.arccos(-1/M1)
    acu = bisection_solve(0.000000001, np.pi, -1, 1e-6, M1, M2, m) # Find acl
    acl = bisection_solve(0.000000001, np.pi, 1, 1e-6, M1, M2, m) # Find acu

    if a < 0:
        ap = np.arctan(np.tan(acp)/((np.tan(ac)/np.tan(aPrime)) - ((1/M2) * np.sqrt((np.tan(ac)/np.tan(aPrime))**2 - 1))))
        if ap < 0:
            ap = ap + np.pi
        decay_rate = 0
        Zeta = 1

    elif a > 0:
        ap = np.arctan(np.tan(acp)/((np.tan(ac)/np.tan(aPrime)) + ((1/M2) * np.sqrt((np.tan(ac)/np.tan(aPrime))**2 - 1))))
        while ap < np.pi:
            ap = ap + np.pi
        decay_rate = 0
        Zeta = 1

    return ap, decay_rate, Zeta

def equation_to_solve(a, sign, M1, M2, m):
    # Equation that is the relationship between alpha and acl and acu
    eq = (1/np.tan(a)) + 1 / (M1 * np.sin(a)) - sign * np.sqrt(1 - M2**2) / (m * M2)
    return eq

def bisection_solve(a_min, a_max, sign, tol, M1, M2, m):
    # Method of Solving for acu and acl becuase there is no exact solultion.
    while abs(a_max - a_min) > tol:
        a_mid = (a_min + a_max) / 2
        if equation_to_solve(a_min, sign, M1, M2, m) * equation_to_solve(a_mid, sign, M1, M2, m) < 0:
            a_max = a_mid
        else:
            a_min = a_mid
    return a_min

def make_A(a,a_s,ap,decay_rate,Zeta,M2,m,gamma):
    # Used to build A matrix. This is used to solve for all following values.
    A = np.array([[np.sin(a_s), -1, (1/gamma) + ((np.cos(ap) + decay_rate*1J)/(gamma * M2 * Zeta)), 1J*(m - 1) * np.cos(a)],
              [2 * np.sin(a_s), -1, ((M2**2 + 1)/(gamma * M2**2)) + ((2 * (np.cos(ap) + 1J * decay_rate))/(gamma * M2 * Zeta)), 0],
              [-np.cos(a_s), 0, (np.sin(ap))/(gamma * M2 * Zeta), 1J * (1 - m) * np.sin(a)],
              [np.sin(a_s), (1/((gamma - 1) * M2**2)), (1 / (gamma * M2**2)) + ((np.cos(ap) + 1J * decay_rate)/(gamma * M2 * Zeta)), 1J * m * (1 - m)*np.cos(a)]])
    return A

def moore(phi, M1, gamma, beta, CritLower, CritUpper):
    M2, PR, m, TR = calculate_M2(M1,gamma,beta)

    V = M1
    U = -V/m + V

    PhiVort = np.arctan((V - U)/(V/np.tan(phi) + 1/np.sin(phi)))
    if PhiVort < 0:
        PhiVort = PhiVort + np.pi

    Cx, Cy = (V - U), 0 
    r = np.sqrt(TR)
    Px, Py =  V, (V/np.tan(phi) + 1/np.sin(phi))

    dx, dy = Px-Cx, Py-Cy
    dxr, dyr = -dy, dx
    d = np.sqrt(dx**2+dy**2)
    if d >= r :
        rho = r/d
        ad = rho**2
        bd = rho*np.sqrt(1-rho**2)
        T1x = Cx + ad*dx + bd*dxr
        T1y = Cy + ad*dy + bd*dyr
        T2x = Cx + ad*dx - bd*dxr
        T2y = Cy + ad*dy - bd*dyr
    
    if phi <= CritLower:
        PhiRefract = np.arctan((Px - T1x)/(Py - T1y))
        decay_rate = 0
        zeta = 1

    elif phi >= CritUpper:
        PhiRefract = np.arctan((Px - T2x)/(Py - T2y))
        if PhiRefract < 0:
            PhiRefract = PhiRefract + np.pi

    return PhiVort, PhiRefract, decay_rate, zeta

def Calc_Zpp(a, M1, beta):
    # Amplitude ratios for incident acoustic waves (V = vorticity, S = entropy, P = pressure/ acoustic, X = position)

    # Post Shock Relations 
    if beta == np.pi/2: # Normal Shock
        M2, PR, m, TR = calculate_M2(M1, gamma, beta)

    elif beta < np.pi/2: # Oblique Shock
        M1, M2, PR, m, TR = calculate_M2(M1, gamma, beta)
    
    # Find Alpha Prime
    aPrime = calculate_aPrime(M1, a)

    # Find Post Shock Entropy/Vorticity angle from incident acoustic
    a_s = alpha_s(aPrime, m)

    # Find Post Shock Acoustic Wave angle from incident acoustic
    ap, decay_rate, Zeta = calculate_decay_rate_prime(M1, M2, m, a, aPrime)

    # Build new A matrix with alpha prime instead of alpha
    APrime = make_A(aPrime, a_s, ap, decay_rate, Zeta, M2, m, gamma)

    # b matrix of equation A27 from Fabre Paper
    d = np.array([
        (1/gamma) + (np.cos(a)/(gamma * M1)),
        (m/gamma) * ((((M1**2) + 1)/(M1**2)) + ((2 * np.cos(a))/M1)),
        (m * np.sin(a))/(gamma * M1),
        ((m**2)/gamma) * ((1/(M1**2)) + (np.cos(a)/M1))
    ])

    # Solve for Z vaules of equation A27
    [Zpv, Zps, Zpp, ZpxSol] = np.linalg.solve(APrime,d) 

    return Zpp * PR

def Calc_Zss(a,M1,beta):

    # Post Shock Relations 
    if beta == np.pi/2: # Normal Shock
        M2, PR, m, TR = calculate_M2(M1, gamma, beta)

    elif beta < np.pi/2: # Oblique Shock
        M1, M2, PR, m, TR = calculate_M2(M1, gamma, beta)
    
    a_s = alpha_s(a,m) # Solve for angles
    ap, decay_rate, Zeta = calculate_decay_rate(M2,m,a) #Solve Other flow properties 

    A = make_A(a,a_s,ap,decay_rate,Zeta,M2,m,gamma) # Build A matrix

    b = np.array([-1, -m, 0, m**2 / ((gamma - 1) * M1**2)]).reshape((-1, 1)) # b matrix of equation A18

    [Zsv, Zss, Zsp, Zsx] = np.linalg.solve(A, b) # Solve for Z vaules of equation A18

    return Zss

def Calc_Zvv(a,M1,beta):
    M2, PR, m, TR = calculate_M2(M1,gamma,beta) # Solve M2
    a_s = alpha_s(a,m) # Solve for angles
    ap, decay_rate, Zeta = calculate_decay_rate(M2,m,a) #Solve Other flow properties 

    A = make_A(a,a_s,ap,decay_rate,Zeta,M2,m,gamma) # Build A matrix

    c = np.array([np.sin(a), 2 * m * np.sin(a), -m * np.cos(a), m**2 * np.sin(a)]).reshape((-1,1))

    [Zvv, Zvs, Zvp, Zvx] = np.linalg.solve(A,c) # Solve for Z vaules of equation A20

    return Zvv/m

data = """-68.27407288231034, 39.88012575177692
-68.27407288231034, 39.74439584472389
-68.27407288231034, 39.60866593767086
-68.27407288231034, 39.472936030617824
-68.27407288231034, 39.33720612356479
-68.27407288231034, 39.20147621651175
-68.27407288231034, 39.06574630945872
-68.27407288231034, 38.930016402405684
-68.27407288231034, 38.79428649535265
-68.27407288231034, 38.65855658829962
-68.27407288231034, 38.522826681246585
-68.27407288231034, 38.387096774193544
-68.27407288231034, 38.25136686714051
-68.27407288231034, 38.11563696008748
-68.27407288231034, 37.979907053034445
-68.27407288231034, 37.84417714598141
-68.27407288231034, 37.70844723892837
-68.27407288231034, 37.57271733187534
-68.27407288231034, 37.436987424822306
-68.27407288231034, 37.30125751776927
-68.27407288231034, 37.09766265718972
-67.47526345426753, 36.55474302897758
-67.47526345426753, 36.41901312192455
-67.47526345426753, 36.28328321487152
-67.47526345426753, 36.14755330781848
-67.47526345426753, 36.011823400765444
-67.47526345426753, 35.87609349371241
-67.47526345426753, 35.74036358665938
-67.47526345426753, 35.604633679606344
-67.47526345426753, 35.468903772553304
-67.47526345426753, 35.33317386550027
-67.47526345426753, 35.19744395844724
-67.47526345426753, 35.061714051394205
-67.47526345426753, 34.92598414434117
-67.47526345426753, 34.79025423728814
-67.47526345426753, 34.6545243302351
-67.47526345426753, 34.518794423182065
-67.47526345426753, 34.38306451612903
-67.47526345426753, 34.281267085839254
-66.67645402622475, 33.84014488791689
-66.67645402622475, 33.70441498086386
-66.67645402622475, 33.568685073810826
-66.67645402622475, 33.43295516675779
-66.67645402622475, 33.29722525970476
-66.67645402622475, 33.16149535265172
-66.67645402622475, 32.89003553854565
-66.67645402622475, 32.788238108255875
-65.87764459818194, 32.55071077091307
-65.87764459818194, 32.07565609622745
-65.87764459818194, 31.93992618917441
-65.87764459818194, 31.804196282121378
-65.47823988416054, 31.702398851831603
-65.07883517013916, 31.397006560962275
-65.07883517013916, 31.295209130672497
-64.28002574209636, 31.193411700382722
-64.28002574209636, 31.05768179332969
-63.481216314053555, 30.921951886276652
-63.08181160003217, 30.78622197922362
-61.484192743946565, 30.684424548933844
-59.886573887860976, 30.701390787315475
-58.28895503177539, 30.78622197922362
-55.493122033625596, 31.02374931656643
-53.096693749497206, 31.22734417714598
-47.90443246721904, 31.736331328594858
-46.30681361113345, 31.838128758884636
-45.10859946906925, 31.905993712411153
-40.274314214463814, 32.266949152542374
-35.9222910465771, 32.686440677966104
-34.3246721904915, 32.77127186987425
-32.72705333440591, 32.89003553854565
-31.12943447832032, 32.9748667304538
-29.53181562223473, 33.076664160743576
-27.934196766149128, 33.16149535265172
-25.537768482020752, 33.280259021323126
-23.0926715469391, 33.39902268999453
-21.94312605582816, 33.46688764352105
-18.747888343656967, 33.60261755057408
-13.092269326683265, 33.813559322033896
-5.860349127182047, 33.96186440677966
-0.12468827930175053, 34.02542372881356
6.608478802992522, 33.91949152542373
12.593516209476292, 33.83474576271186
17.33167082294267, 33.66525423728814
21.991392486525626, 33.46688764352105
23.988416056632616, 33.36509021323127
25.58603491271819, 33.280259021323126
27.982463196846595, 33.14452911427009
29.580082052932198, 33.042731683980314
31.177700909017773, 32.94093425369054
32.775319765103376, 32.839136823400764
34.37293862118895, 32.737339393110986
36.36996219129594, 32.65250820120284
40.77306733167083, 32.266949152542374
45.556270613788115, 31.889027474029525
46.7544847558523, 31.77026380535812
55.54138846432306, 31.02374931656643
57.53841203443005, 30.837120694368508
59.13603089051563, 30.73532326407873
60.73364974660123, 30.684424548933844
62.33126860268683, 30.75228950246036
63.52948274475102, 30.98981683980317
63.52948274475102, 30.888019409513397
64.32829217279382, 31.32914160743576
64.32829217279382, 31.193411700382722
65.1271016008366, 31.93992618917441
65.1271016008366, 31.804196282121378
65.1271016008366, 31.66846637506834
65.1271016008366, 31.532736468015308
65.1271016008366, 31.430939037725533
65.9259110288794, 32.788238108255875
65.9259110288794, 32.55071077091307
65.9259110288794, 32.1095885729907
66.32531574290081, 32.89003553854565
66.7247204569222, 34.6545243302351
66.7247204569222, 34.518794423182065
66.7247204569222, 34.38306451612903
66.7247204569222, 34.247334609076
66.7247204569222, 34.11160470202296
66.7247204569222, 33.975874794969926
66.7247204569222, 33.84014488791689
66.7247204569222, 33.70441498086386
66.7247204569222, 33.568685073810826
66.7247204569222, 33.43295516675779
66.7247204569222, 33.29722525970476
66.7247204569222, 33.16149535265172
67.523529884965, 39.67653089119737
67.523529884965, 39.54080098414434
67.523529884965, 39.40507107709131
67.523529884965, 39.269341170038274
67.523529884965, 39.133611262985234
67.523529884965, 38.9978813559322
67.523529884965, 38.86215144887917
67.523529884965, 38.726421541826134
67.523529884965, 38.5906916347731
67.523529884965, 38.45496172772006
67.523529884965, 38.31923182066703
67.523529884965, 38.183501913613995
67.523529884965, 38.04777200656096
67.523529884965, 37.91204209950793
67.523529884965, 37.776312192454895
67.523529884965, 37.640582285401855
67.523529884965, 37.50485237834882
67.523529884965, 37.36912247129579
67.523529884965, 37.233392564242756
67.523529884965, 37.09766265718972
67.523529884965, 36.96193275013668
67.523529884965, 36.82620284308365
67.523529884965, 36.690472936030616
67.523529884965, 36.55474302897758
67.523529884965, 36.41901312192455
67.523529884965, 36.28328321487152
67.523529884965, 36.14755330781848
67.523529884965, 36.011823400765444
67.523529884965, 35.87609349371241
67.523529884965, 35.74036358665938
67.523529884965, 35.604633679606344
67.523529884965, 35.468903772553304
67.523529884965, 35.33317386550027
67.523529884965, 35.19744395844724
67.523529884965, 35.061714051394205
67.523529884965, 34.92598414434117
67.523529884965, 34.82418671405139
68.3223393130078, 39.77832832148715"""

rad = np.pi / 180
# Inputs Enter Here
M1 = 8 # Mach 1 Entry
gamma = 5/3
beta = 60 * rad

ZppNorm, ZppStrong, ZppWeak = [], [], []
ZvvList = []
alpha3 = []

aM, acu, acl, ac = Crit_Angles(M1, gamma,beta)

a = -acl
while a <= acl:
    ZppNorm.append(Calc_Zpp(a,M1,beta))
    # ZppNorm.append(Calc_Zvv(a,M1,beta))
    alpha3.append(a/rad)
    a = a + 0.1 * rad

# Split the data into lines and extract X and Y coordinates
lines = data.strip().split('\n') 
x_data = [] 
y_data = []
for line in lines:     
    x, y = map(float, line.split(','))     
    x_data.append(x)     
    y_data.append(y)

# aM, acu, acl, ac = Crit_Angles(M1, gamma,90*rad)
# alphaStrong = np.linspace(-acl + 1*2*np.pi / 180, acl - 1*2*np.pi / 180, 200)

# for a in alphaStrong:
#     ZppStrong.append(Calc_Zpp(a,M1,90*rad))

plt.figure
plt.plot(alpha3,np.real(ZppNorm), label = 'Calculated Solution', color = 'blue')

plt.plot(x_data,y_data, label = 'Westphal Solution', color = 'Red')

plt.xlabel('Theta [deg]')
plt.ylabel("p2'/p1")
plt.grid()
plt.ylim(0,50)
plt.savefig('/workspaces/Research/Zpp.png')
plt.show

plt.figure
a = -ac
ZssList = []
alpha2 = []

while a < ac:
     ZssList.append(-Calc_Zpp(a,M1,beta)/Calc_Zss(a,M1,beta))
     alpha2.append(a * 180/pi)
     a = a + 1e-2


plt.plot(alpha2,np.real(ZssList))
plt.xlabel('Theta [deg]')
plt.ylabel("Ge")
plt.grid()
plt.ylim(-60,0)
plt.savefig('/workspaces/Research/Zss.png')


# while a < ac:
#     ZvvList.append((Calc_Zvv(a,M1,beta)))
#     alpha3.append(a * 180/pi)
#     a = a + 1e-2


# plt.plot(alpha3,ZvvList)
# plt.xlabel('Theta [deg]')
# plt.ylabel("Gv")
# plt.grid()
# plt.savefig('/workspaces/Research/Zvv.png')

